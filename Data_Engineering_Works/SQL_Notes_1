Pivot operations on table:

The PIVOT statement is used to convert table rows into columns, while the UNPIVOT operator converts columns back to rows. Reversing a PIVOT statement refers to the process of applying the  UNPIVOT operator to the already PIVOTED dataset in order to retrieve the original dataset.
In this article, we will study these three concepts on different examples.
PIVOT Operator
As mentioned earlier, the PIVOT operator converts table rows into columns. For example, if you have a table that looks like this:
Syntax
The following syntax summarizes how to use the PIVOT operator.
Copy
SELECT <non-pivoted column>,  
    [first pivoted column] AS <column name>,  
    [second pivoted column] AS <column name>,  
    ...  
    [last pivoted column] AS <column name>  
FROM  
    (<SELECT query that produces the data>)   
    AS <alias for the source query>  
PIVOT  
(  
    <aggregation function>(<column being aggregated>)  
FOR   
[<column that contains the values that will become column headers>]   
    IN ( [first pivoted column], [second pivoted column],  
    ... [last pivoted column])  
) AS <alias for the pivot table>  
<optional ORDER BY clause>;  
Basic PIVOT Example
The following code example produces a two-column table that has four rows.
SQLCopy
USE AdventureWorks2014 ;  
GO  
SELECT DaysToManufacture, AVG(StandardCost) AS AverageCost   
FROM Production.Product  
GROUP BY DaysToManufacture;  
Here is the result set.
Copy
DaysToManufacture AverageCost
----------------- -----------
0                 5.0885
1                 223.88
2                 359.1082
4                 949.4105
No products are defined with three DaysToManufacture.
The following code displays the same result, pivoted so that the DaysToManufacture values become the column headings. A column is provided for three [3] days, even though the results are NULL.
SQLCopy
-- Pivot table with one row and five columns  
SELECT 'AverageCost' AS Cost_Sorted_By_Production_Days,   
[0], [1], [2], [3], [4]  
FROM  
(SELECT DaysToManufacture, StandardCost   
    FROM Production.Product) AS SourceTable  
PIVOT  
(  
AVG(StandardCost)  
FOR DaysToManufacture IN ([0], [1], [2], [3], [4])  
) AS PivotTable;  
  
Here is the result set.
Copy
Cost_Sorted_By_Production_Days 0           1           2           3           4         
------------------------------ ----------- ----------- ----------- ----------- -----------
AverageCost                    5.0885      223.88      359.1082    NULL        949.4105
Complex PIVOT Example
A common scenario where PIVOT can be useful is when you want to generate cross-tabulation reports to give a summary of the data. For example, suppose you want to query the PurchaseOrderHeader table in the AdventureWorks2014 sample database to determine the number of purchase orders placed by certain employees. The following query provides this report, ordered by vendor.
SQLCopy

USE AdventureWorks2014;  
GO  
SELECT VendorID, [250] AS Emp1, [251] AS Emp2, [256] AS Emp3, [257] AS Emp4, [260] AS Emp5  
FROM   
(SELECT PurchaseOrderID, EmployeeID, VendorID  
FROM Purchasing.PurchaseOrderHeader) p  
PIVOT  
(  
COUNT (PurchaseOrderID)  
FOR EmployeeID IN  
( [250], [251], [256], [257], [260] )  
) AS pvt  
ORDER BY pvt.VendorID;  
Here is a partial result set.
Copy
VendorID    Emp1        Emp2        Emp3        Emp4        Emp5  
----------- ----------- ----------- ----------- ----------- -----------
1492        2           5           4           4           4
1494        2           5           4           5           4
1496        2           4           4           5           5
1498        2           5           4           4           4
1500        3           4           4           5           4
The results returned by this subselect statement are pivoted on the EmployeeID column.
SQLCopy
SELECT PurchaseOrderID, EmployeeID, VendorID  
FROM PurchaseOrderHeader;  
The unique values returned by the EmployeeID column become fields in the final result set. As such, there's a column for each EmployeeID number specified in the pivot clause: in this case employees 164, 198, 223, 231, and 233. The PurchaseOrderID column serves as the value column, against which the columns returned in the final output, which are called the grouping columns, are grouped. In this case, the grouping columns are aggregated by the COUNTfunction. Notice that a warning message appears that indicates that any null values appearing in the PurchaseOrderID column weren't considered when computing the COUNT for each employee.
 Important
When aggregate functions are used with PIVOT, the presence of any null values in the value column are not considered when computing an aggregation.
UNPIVOT carries out almost the reverse operation of PIVOT, by rotating columns into rows. Suppose the table produced in the previous example is stored in the database as pvt, and you want to rotate the column identifiers Emp1, Emp2, Emp3, Emp4, and Emp5 into row values that correspond to a particular vendor. As such, you must identify two additional columns. The column that will contain the column values that you're rotating (Emp1, Emp2,...) will be called Employee, and the column that will hold the values that currently exist under the columns being rotated will be called Orders. These columns correspond to the pivot_columnand value_column, respectively, in the Transact-SQL definition. Here is the query.
SQLCopy
-- Create the table and insert values as portrayed in the previous example.  
CREATE TABLE pvt (VendorID int, Emp1 int, Emp2 int,  
    Emp3 int, Emp4 int, Emp5 int);  
GO  
INSERT INTO pvt VALUES (1,4,3,5,4,4);  
INSERT INTO pvt VALUES (2,4,1,5,5,5);  
INSERT INTO pvt VALUES (3,4,3,5,4,4);  
INSERT INTO pvt VALUES (4,4,2,5,5,4);  
INSERT INTO pvt VALUES (5,5,1,5,5,5);  
GO  
-- Unpivot the table.  
SELECT VendorID, Employee, Orders  
FROM   
   (SELECT VendorID, Emp1, Emp2, Emp3, Emp4, Emp5  
   FROM pvt) p  
UNPIVOT  
   (Orders FOR Employee IN   
      (Emp1, Emp2, Emp3, Emp4, Emp5)  
)AS unpvt;  
GO  
Here is a partial result set.
Copy
VendorID    Employee    Orders
----------- ----------- ------
1            Emp1       4
1            Emp2       3 
1            Emp3       5
1            Emp4       4
1            Emp5       4
2            Emp1       4
2            Emp2       1
2            Emp3       5
2            Emp4       5
2            Emp5       5
...
Notice that UNPIVOT isn't the exact reverse of PIVOT. PIVOT carries out an aggregation and merges possible multiple rows into a single row in the output. UNPIVOT doesn't reproduce the original table-valued expression result because rows have been merged. Also, null values in the input of UNPIVOT disappear in the output. When the values disappear, it shows that there may have been original null values in the input before the PIVOT operation.
The Sales.vSalesPersonSalesByFiscalYears view in the AdventureWorks2012 sample database uses PIVOT to return the total sales for each salesperson, for each fiscal year. To script the view in SQL Server Management Studio, in Object Explorer, locate the view under the Views folder for the AdventureWorks2012 database. Right-click the view name, and then select Script View as.



 
In the original table, we had two unique values for the Course columns – English and History. In the pivoted table, these unique values have been converted into columns. You can see that the score values for each new column remain unchanged. For instance, in the original table, a student, Sally, had scored 95 in English, unlike the values in the pivoted table.
CREATE DATABASE School
GO
USE School
GO
CREATE TABLE Students
(
	Id INT PRIMARY KEY IDENTITY,
	StudentName VARCHAR (50),
	Course VARCHAR (50),
	Score INT
)
GO

INSERT INTO Students VALUES ('Sally', 'English', 95 )
INSERT INTO Students VALUES ('Sally', 'History', 82)
INSERT INTO Students VALUES ('Edward', 'English', 45)
INSERT INTO Students VALUES ('Edward', 'History', 78)
The script above creates the School database. In the database, we create the Students table with four columns, such as Id, StudentName, Course, and Score. Finally, we add the four dummy records to the Students table.

Let’s PIVOT this table by the Course column. To do this, execute the following script:
SELECT * FROM 
(SELECT 
	StudentName,
	Score,
	Course
FROM 
	Students
)
AS StudentTable
PIVOT(
	SUM(Score)
	FOR Course IN ([English],[History])
) AS SchoolPivot

Let’s see what is happening in the script. In the first line, we use the SELECT statement to define the columns that we want to add to the pivoted table. The first two columns are StudentName and Score. The data for these two columns will come directly from the Students table. The third column is Course. We want to PIVOT our table by the Course column, therefore, the Course column will be split into the number of columns equal to the values specified by the PIVOT operator for the Course column.
The syntax for the PIVOT operator is simple. First, you have to apply an aggregate function to the column the values of which you want to display in the pivoted columns. In our case, we want to show Score in the pivoted columns – English and History. Finally, we use a FOR statement to specify the pivot column and the unique values in it. 
UNPIVOT Operator
The UNPIVOT operator is used to convert table columns into rows. For instance, if you have a table that looks like this:
 
The columns of the original table have been converted to the rows in the unpivoted table. Let’s use that data to see how the UNPIVOT operator works in SQL.
To do this, execute the following script:
CREATE DATABASE School2
GO

USE School2
GO

CREATE TABLE Students
(
	Id INT PRIMARY KEY IDENTITY,
	StudentName VARCHAR (50),
	Math INT,
	English INT,
	History INT,
	Science INT
)
GO

INSERT INTO Students VALUES ('Sally', 78, 85, 91, 76 )
INSERT INTO Students VALUES ('Edward', 87, 90, 82, 87)
To apply the UNPIVOT operator to this table, run the following query:
SELECT StudentName, Course, Score
FROM Students
UNPIVOT
(
	Score
	FOR Course in (Math, English, History, Science)
) AS SchoolUnpivot

Reversing a PIVOT
Reversing a PIVOT operator refers to the process of applying the UNPIVOT operator to a pivoted table in order to get back to the original table.
Reversing Non-aggregate Pivoted Table
Reversing a PIVOT operator is only possible if the pivoted table doesn’t contain aggregated data.
Let’s look at the table we used in the PIVOT section of this article.
 
Now, we are going to apply the UNPIVOT operator to this result and see if we can get back to the original table. To do this, execute the following script:
SELECT StudentName, Course, Score
FROM
(SELECT * FROM
 
(SELECT 
	StudentName,
	Score,
	Course
FROM 
	Students
)
AS StudentTable
PIVOT(
	SUM(Score)
	FOR Course IN ([English],[History])
) AS SchoolPivot) PivotedResults
UNPIVOT
(
	Score
	FOR Course in (English, History)
) AS Schoolunpivot
Here we use a subquery to apply the UNPIVOT operator to the pivoted data. The inner query employs the PIVOT operator, while the outer query uses the UNPIVOT operator. At the output, you will see the original Students table.
Reversing Aggregated Pivoted Table
We said earlier that it is possible only to reverse a PIVOT operator that doesn’t contain aggregated data. Let’s try to reverse the PIVOT statement that contains aggregated data.
Add another record to the Students table of the School database that we created in the first section of this article. To do this, run the following query:
CREATE TABLE Students
(
	Id INT PRIMARY KEY IDENTITY,
	StudentName VARCHAR (50),
	Course VARCHAR (50),
	Score INT
)
GO

INSERT INTO Students VALUES ('Sally', 'English', 95 )
INSERT INTO Students VALUES ('Sally', 'History', 82)
INSERT INTO Students VALUES ('Edward', 'English', 45)
INSERT INTO Students VALUES ('Edward', 'History', 78)

select * from Students

INSERT INTO Students VALUES ('Edward', 'History', 78)
Now, if you select all the records from the Students table, you will get the following output:
 
We can see that we have a duplicate record for Edward’s score in History.
Now, apply the PIVOT operator to this table.
SELECT Id, StudentName, English, History
FROM Students
PIVOT
(
	SUM (Score)
	FOR Course in (English, History)
) AS Schoolpivot
Given Output						Occurred Output				
 


From the output, you can see that the SUM function in the PIVOT operator has added two scores to the History course taken by Edward. If you try to reverse the pivot of this table (i.e. apply the UNPIVOT operator), you will not receive the original table. It will return the four records instead of the original five. The History column for the student Edward will contain the aggregated result rather than the individual results.
To see this, execute the following script:
SELECT StudentName, Course, Score
FROM
(SELECT * FROM
 
(SELECT 
	StudentName,
	Score,
	Course
FROM 
	Students
)
AS StudentTable
PIVOT(
	SUM(Score)
	FOR Course IN ([English],[History])
) AS SchoolPivot) PivotedResults
UNPIVOT
(
	Score
	FOR Course in (English, History)
) AS Schoolunpivot
 






Example ::
Need to count the different flags present in the columns and printing the result in single row


CREATE TABLE Pract_Students
(
	col INT
)

INSERT INTO Pract_Students VALUES (1)

INSERT INTO Pract_Students VALUES (-1)

INSERT INTO Pract_Students VALUES (-1)

INSERT INTO Pract_Students VALUES (1)

INSERT INTO Pract_Students VALUES (1)

INSERT INTO Pract_Students VALUES (-1)

INSERT INTO Pract_Students VALUES (1)
select col,count(*) as c1 from Pract_Students group by col
 

select 1 as 'C1', -1 as 'C-1' from ( select col,count(*) as c1 from Pract_Students group by col) as s1  Pivot (sum(c1) for col in ([1] ,[-1]) ) as pivot1
 

SQL SUBQUIRES : 
https://www.w3resource.com/sql-exercises/subqueries/index.php#SQLEDITOR

Write a query to find all the orders issued against the salesman who may works for customer whose id is 3007
SELECT * FROM orders WHERE salesman_id = (SELECT DISTINCT salesman_id 
     FROM orders WHERE customer_id =3007);

Write a query to find the name and numbers of all salesmen who had more than one customer.
SELECT salesman_id,name FROM salesman a WHERE 1 < (SELECT COUNT(*) 
     FROM customer WHERE salesman_id=a.salesman_id);

Write a query to display all the orders which values are greater than the average order value for 10th October 2012

SELECT * FROM orders WHERE purch_amt > (SELECT  AVG(purch_amt) 
     FROM orders WHERE ord_date ='10/10/2012');

Write a query to display all the customers whose id is 2001 bellow the salesman ID of Mc Lyon

SELECT * FROM customer WHERE customer_id = (SELECT salesman_id -2001 FROM salesman WHERE name = 'Mc Lyon');

Write a query to count the customers with grades above New York's average. 

SELECT grade, COUNT (*) FROM customer GROUP BY grade HAVING grade >
    (SELECT AVG(grade) FROM customer WHERE city = 'New York');


Write a query to find all orders with order amounts which are above-average amounts for their customers. 

SELECT * FROM orders a WHERE purch_amt >(SELECT AVG(purch_amt) FROM orders b WHERE b.customer_id = a.customer_id);

Write a query to find the sums of the amounts from the orders table, grouped by date, eliminating all those dates where the sum was not at least 1000.00 above the maximum order amount for that date.

SELECT ord_date, SUM (purch_amt) FROM orders a GROUP BY ord_date
HAVING SUM (purch_amt) > (SELECT 1000.00 + MAX(purch_amt) 
     FROM orders b WHERE a.ord_date = b.ord_date);

Write a query to extract the data from the customer table if and only if one or more of the customers in the customer table are located in London.

SELECT customer_id,cust_name, city FROM customer WHERE EXISTS
   (SELECT * FROM customer WHERE city='London');

Write a query to find the salesmen who have multiple customers. 

SELECT * FROM salesman WHERE salesman_id IN (
   SELECT DISTINCT salesman_id FROM customer a WHERE EXISTS 
(SELECT * FROM customer b WHERE b.salesman_id=a.salesman_id 
      AND b.cust_name<>a.cust_name));
 Write a query to find all the salesmen who worked for only one customer.

SELECT * FROM salesman WHERE salesman_id IN (SELECT DISTINCT salesman_id 
   FROM customer a WHERE NOT EXISTS (SELECT * FROM customer b 
      WHERE a.salesman_id=b.salesman_id AND a.cust_name<>b.cust_name));
Write a query that extract the rows of all salesmen who have customers with more than one orders.

SELECT * FROM salesman a WHERE EXISTS (SELECT * FROM customer b     
    WHERE a.salesman_id=b.salesman_id AND 1<(SELECT COUNT (*)              
		  FROM orders WHERE orders.customer_id = b.customer_id));

Write a query to find all the salesmen for whom there are customers that follow them.

SELECT * FROM salesman WHERE city IN (SELECT city FROM customer);


